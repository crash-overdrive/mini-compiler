object WLP4Scan {

  /* It might be more efficient to define states as Symbols or something similar,
     but we use Strings for simplicity here. Feel free to change this.
   */
  case class DFA(states: Set[String], alphabet: Set[Char], transition: PartialFunction[(String, Char), String],
            start: String, accepting: Set[String]) {
    
    require(accepting subsetOf states)
    require(states contains start)

    /* This is unused elsewhere, but exists for completeness' sake.
     * It is extremely similar to scanOne in simplifiedMaximalMunch below, except it runs until
     * input is exhausted in all cases.
     */
    def recognize(input: Seq[Char], state: String = start): Boolean =
      if (input.isEmpty) accepting contains state
      else if (transition.isDefinedAt((state,input.head))) recognize(input.tail,transition((state,input.head)))
      else false

      /* recognize can also be defined in terms of abstract list functions, for example:
       * input.foldLeft(Some(start): Option[String])((st, ch) => st.flatMap(x => transition.lift((x, ch)))) match {
       *   case Some(state) => accepting contains state
       *   case None        => false
       * }
       */
  }

  /* A list of all keywords that are generalised to an ID token
   */
  val wlp4IDKeywords: Set[String] = Set("WAIN", "INT", "IF", "ELSE", "WHILE", "PRINTLN", "RETURN", "NULL", "NEW", "DELETE")

  /* A list of all tokens which can be generated by scanning CS241 WLP4 assembly code */
  val wlp4Tokens: Set[String]      = wlp4IDKeywords ++ Set("ID", "NUM", "LPAREN", "RPAREN", "LBRACE", "RBRACE", "BECOMES", "EQ", "NE", "LT", "GT", 
                                 "LE", "GE", "PLUS", "MINUS", "STAR", "SLASH", "PCT", "COMMA", "SEMI", "LBRACK", "RBRACK", "AMP")
  val wlp4DFA: DFA = {
    /* -- is "set difference" in scala, while ++ is "set union" for sets */
    //wlp4Tokens returns all the list of tokens produced by our lexer

    val dfaAccepting: Set[String] = (wlp4Tokens -- wlp4IDKeywords) ++ Set("ZERONUM", "WHITESPACE", "COMMENT") 
    val dfaStates:    Set[String] = dfaAccepting ++ Set("START", "NOT", "ZEROERROR")  
    DFA(
      states     = dfaStates,
      start      = "START",
      alphabet   = "(){}[]=!<>+-*/%,;&".toSet ++ ('a' to 'z') ++ ('A' to 'Z') ++ ('0' to '9'),
      accepting  = dfaAccepting,
      /* A partial function is essentially a map: an association between keys (in this case a state & letter
       * with values (in this case another state). However, we can use the more powerful pattern matching
       * syntax to write them, such as how this DFA is defined.
       */
      transition = {
        case ("START",x)      if x.isLetter               => "ID"
        case ("ID",x)         if x.isLetterOrDigit        => "ID"

        case ("START",'0')                                => "ZERONUM"
        case ("ZERONUM", x)   if x.isLetterOrDigit        => "ZEROERROR"
        case ("START",x)      if x.isDigit && x!= 0       => "NUM"
        case ("NUM",x)        if x.isDigit                => "NUM"

        case ("START",'(')                                => "LPAREN"
        case ("START",')')                                => "RPAREN"

        case ("START",'{')                                => "LBRACE"
        case ("START",'}')                                => "RBRACE"

        case ("START",'=')                                => "BECOMES"      
        case ("BECOMES", '=')                             => "EQ"

        case ("START", '!')                               => "NOT"
        case ("NOT", '=')                                 => "NE"

        case ("START", '<')                               => "LT"
        case ("START", '>')                               => "GT"
        case ("LT", '=')                                  => "LE"
        case ("GT", '=')                                  => "GE"

        case ("START",'+')                                => "PLUS"
        case ("START",'-')                                => "MINUS"
        //case ("MINUS",x)      if x.isDigit                => "INT"
        case ("START",'*')                                => "STAR"
        case ("START",'/')                                => "SLASH"
        case ("START",'%')                                => "PCT"

        case ("START",',')                                => "COMMA"
        case ("START",';')                                => "SEMI"
        case ("START",'[')                                => "LBRACK"
        case ("START",']')                                => "RBRACK"        

        case ("START",'&')                                => "AMP"

        case ("SLASH", '/')                               => "COMMENT"
        case ("COMMENT",x)    if x != '\n'                => "COMMENT"

        case ("START",x)      if x.isWhitespace           => "WHITESPACE"
        case ("WHITESPACE",x) if x.isWhitespace           => "WHITESPACE"
        
        
        
      }
    )
  }

  /* A scanned token, which stores both its kind and lexeme.
   * You could improve the error messages generated by this scanner by also remembering line number and column
   * information.
   */
  case class Token(kind: String, lexeme: String) {
    /* Should only be called on tokens of type NUM */
    def toLong: Long = {
      kind match {
        case "NUM" => lexeme.toLong
      }
    }
  }

  /* An implementation of the Simplified Maximal Munch algorithm,
   * which will be presented in class around the time of Assignment 6.
   */
  def simplifiedMaximalMunch(dfa: DFA, input: List[Char]): Seq[Token] = {
    /* Munch the longest possible token and return it along with the remaining unconsumed input */
    def scanOne(input: List[Char], state: String = dfa.start, consumedInput: List[Char] = Nil): (List[Char], Token) = {
      if (input.isEmpty || !dfa.transition.isDefinedAt((state,input.head))) {
        if (dfa.accepting contains state) {
          return (input,Token(state,consumedInput.reverse.mkString))
        }
        else {
          sys.error(s"ERROR: simplified maximal munch failed on input: ${consumedInput.reverse ++ input}")
        }
      }
      else {
        return scanOne(input.tail, dfa.transition((state,input.head)), input.head :: consumedInput)
      }
    }
      

    /* Repeatedly call scanOne until the input is consumed or an error occurs */
    def scanAll(input: List[Char], accum: List[Token] = Nil): Seq[Token] = input match {
      case Nil => accum.reverse
      case _   =>
        val (remainingInput, tok) = scanOne(input)
        scanAll(remainingInput, tok :: accum)
    }
    scanAll(input)
  }

  def scan(input: String): Seq[Token] = {
    
    /* Map can accept a partial function if you use curly braces {} instead of parens ().
     */
    val tokens = simplifiedMaximalMunch(wlp4DFA, input.toList).map {
      case Token("ID", x) => x match {
        case "wain" => Token(x.toUpperCase, x)
        case "int" => Token(x.toUpperCase, x)
        case "if" => Token(x.toUpperCase, x)
        case "else" => Token(x.toUpperCase, x)
        case "while" => Token(x.toUpperCase, x)
        case "println" => Token(x.toUpperCase, x)
        case "return" => Token(x.toUpperCase, x)
        case "NULL" => Token(x.toUpperCase, x)
        case "new" => Token(x.toUpperCase, x)
        case "delete" => Token(x.toUpperCase, x)
        case default => Token("ID", default)
      }
      case Token("ZERONUM", x) =>   
        Token("NUM", x)
      case default =>                                        
        default
        /* Scala tip: For lambda functions which only use their argument in one place, you can
         * usually use an _ rather than defining a variable explicitly. The filter below is
         * equivalent to filter(x => wlp4Tokens contains x.kind)
         */
    }.filter(wlp4Tokens contains _.kind) /* Remove whitespace and comments */

    /* The scanner accepts ints and registers of any size, but we only want to accept sufficiently small ones */
    def checkRange(t: Token): Unit = {
      try {
        t match {
          case Token("NUM",x) =>
            if (x.toLong > 2147483647) sys.error(s"ERROR: Integer out of range: ${t.lexeme}")
          /*
          case Token("HEXINT",_) =>
            if (t.toLong > 4294967295l) sys.error(s"ERROR: Hexint out of range: ${t.lexeme}")
          case Token("REG",x)    =>
            if (t.toLong > 31l || t.toLong < 0l) sys.error(s"ERROR: Register out of range: ${t.lexeme}")
          */
          case _ => Unit
        }
      } 
      catch {
        case e: NumberFormatException => sys.error(s"ERROR: Integer out of range: ${t.lexeme}")
      }
    }

    tokens.foreach(checkRange)
    tokens
  }
  val tokenLines: Seq[Seq[Token]] = io.Source.stdin.getLines.map(scan).toSeq

  type SymbolTable = Map[String, Int]

  /*
   * This currently just prints tokens one-by-one to standard output.
   * You should replace this with your assembler code.
   */
  def assemble(): Unit = {
    for (tokenLine <- tokenLines) {
      /* For short function calls such as this one, you can use a foreach as well, such as
       * tokenLine.foreach(println)
       */
      for (token <- tokenLine) {
        println(token. kind + " " + token.lexeme)
      }
    }
  }

  def main(args: Array[String]): Unit = assemble()
}
